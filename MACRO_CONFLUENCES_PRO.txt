//+------------------------------------------------------------------+
//|                                                  MacroConfluencePro.mq5 |
//|                                                                  |
//|                                                                  |
//+------------------------------------------------------------------+
#property copyright "MacroConfluencePro"
#property link      ""
#property version   "4.25"
#property indicator_chart_window
#property indicator_buffers 0
#property indicator_plots 0

//‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
//‚ñà  SEC√á√ÉO 1: INPUTS DO UTILIZADOR                                 ‚ñà
//‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà

input group "===== CONFIGURA√á√ÉO B√ÅSICA ====="
input int    SMA_PERIOD         = 200;
input int    RSI_PERIOD         = 14;

input group "===== CONFIGURA√á√ÉO DE CORES ====="
input bool   DARK_MODE          = false;
input color  COL_TREND_UP       = clrForestGreen;
input color  COL_TREND_DOWN     = clrRed;
input color  COL_TREND_SIDE     = clrOrange;
input color  COL_RSI_OVERBOUGHT = clrRed;
input color  COL_RSI_OVERSOLD   = clrForestGreen;
input color  COL_RSI_NEUTRAL    = clrOrange;
input color  COL_ACTION_BUY     = clrForestGreen;
input color  COL_ACTION_SELL    = clrRed;
input color  COL_ACTION_WAIT    = clrOrange;
input color  COL_CONTRA_TREND   = clrMagenta;
input color  COL_CONFLUENCE_ACTIVE = clrDodgerBlue;

input group "===== CONFIGURA√á√ÉO PRICE ACTION ====="
input bool   ENABLE_PRICE_ACTION = true;
input int    PA_CANDLES_LOOKBACK = 5;
input double PA_MIN_BODY_RATIO   = 0.6;
input color  COL_PA_GREEN        = clrForestGreen;
input color  COL_PA_RED          = clrRed;
input color  COL_PA_NEUTRAL      = clrGray;

input group "===== CONFIGURA√á√ÉO DO PAINEL VISUAL ====="
input int    PANEL_POSITION_X   = 300;
input int    PANEL_POSITION_Y   = 60;
input int    PANEL_WIDTH        = 285;
input string FONT_NAME          = "Arial";
input int    FONT_SIZE          = 10;

input group "===== CONFIGURA√á√ÉO AVAN√áADA ====="
input bool   SHOW_FIBONACCI         = true;
input bool   SHOW_SUPPORT_RESISTANCE = true;
input bool   SHOW_RSI               = true;
input bool   SHOW_PRICE_ACTION      = true;
input int    SR_CANDLES             = 10;

input group "===== CONFIRMA√á√ÉO MULTI-TIMEFRAME ====="
input bool   ENABLE_MTF_CONFIRMATION = true;
input ENUM_TIMEFRAMES MTF_1 = PERIOD_H4;
input ENUM_TIMEFRAMES MTF_2 = PERIOD_D1;

input group "===== SISTEMA DE ALERTAS ====="
input bool   ENABLE_ALERTS = true;
input bool   SOUND_ALERTS  = true;
input string ALERT_SOUND   = "alert2.wav";

//‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
//‚ñà  SEC√á√ÉO 2: VARI√ÅVEIS GLOBAIS                                   ‚ñà
//‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà

int handle_sma_chart = INVALID_HANDLE;
int handle_rsi_chart = INVALID_HANDLE;
int handle_ema_20 = INVALID_HANDLE;
int handle_ema_50 = INVALID_HANDLE;
int handle_atr = INVALID_HANDLE;

string PREFIX = "MCP_";

// Price Action Variables
bool pa_bullish = false;
bool pa_bearish = false;
bool pa_valid = false;
color pa_color = COL_PA_NEUTRAL;
string pa_text = "";
string pa_pattern = "";
int pa_current_pattern = 0;
color pa_current_color = clrGray;
bool pa_active = false;
datetime pa_last_pattern_time = 0;
string pa_current_description = "";

// RSI and Alert Variables
int rsi_col = COL_RSI_NEUTRAL;
bool alert_triggered = false;
datetime last_alert_time = 0;
datetime last_calculation = 0;
int calculation_interval = 1;

// Support Resistance Variables
double current_support_level = 0;
double current_resistance_level = 0;

// Fibonacci Variables
datetime fib_start_time = 0;
datetime fib_end_time = 0;
double fib_start_price = 0;
double fib_end_price = 0;
string fib_explanation = "";
bool fib_drawn = false;

// Confluence Variables
bool contra_trend_signal = false;
string contra_trend_type = "";

bool rsi_oversold_normal = false;
bool rsi_overbought_normal = false;
bool rsi_oversold_contra = false;
bool rsi_overbought_contra = false;
bool support_valid_normal = false;
bool resistance_valid_normal = false;
bool support_valid_contra = false;
bool resistance_valid_contra = false;
bool fib_valid_normal = false;
bool fib_valid_contra = false;
bool pa_valid_normal = false;
bool pa_valid_contra = false;
bool mtf_valid_normal = false;
bool mtf_valid_contra = false;

string mtf_aligned_tfs = "";
string mtf_direction = "";

// Vari√°veis para controle do alerta sonoro
datetime last_sound_time = 0;
string last_signal_candle = "";
bool sound_playing = false;

//‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
//‚ñà  SEC√á√ÉO 3: FUN√á√ïES UTILIT√ÅRIAS                                  ‚ñà
//‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà

bool ObjExists(string name) 
{ 
   return ObjectFind(0, name) >= 0; 
}

void SafeDelete(string name) 
{ 
   if(ObjExists(name)) 
      ObjectDelete(0, name); 
}

string GetSimpleTFName(ENUM_TIMEFRAMES tf)
{
   switch(tf)
   {
      case PERIOD_M1: return "M1";
      case PERIOD_M5: return "M5";
      case PERIOD_M15: return "M15";
      case PERIOD_M30: return "M30";
      case PERIOD_H1: return "H1";
      case PERIOD_H4: return "H4";
      case PERIOD_D1: return "D1";
      case PERIOD_W1: return "W1";
      case PERIOD_MN1: return "MN";
      default: return "CURRENT";
   }
}

void DeleteAllObjects()
{
   int total = ObjectsTotal(0);
   for(int i = total-1; i >= 0; i--)
   {
      string name = ObjectName(0, i);
      if(StringFind(name, PREFIX) == 0)
         ObjectDelete(0, name);
   }
}

void CreatePanelLabel(string name, int x, int y, color clr, string text, int font_size = -1)
{
   name = PREFIX + name;
   if(!ObjExists(name)) 
      ObjectCreate(0, name, OBJ_LABEL, 0, 0, 0);
   
   ObjectSetInteger(0, name, OBJPROP_CORNER, CORNER_RIGHT_UPPER);
   ObjectSetInteger(0, name, OBJPROP_XDISTANCE, x);
   ObjectSetInteger(0, name, OBJPROP_YDISTANCE, y);
   ObjectSetInteger(0, name, OBJPROP_COLOR, clr);
   ObjectSetInteger(0, name, OBJPROP_FONTSIZE, font_size == -1 ? FONT_SIZE : font_size);
   ObjectSetString(0, name, OBJPROP_FONT, FONT_NAME);
   ObjectSetString(0, name, OBJPROP_TEXT, text);
   ObjectSetInteger(0, name, OBJPROP_SELECTABLE, false);
   ObjectSetInteger(0, name, OBJPROP_BACK, false);
   ObjectSetInteger(0, name, OBJPROP_HIDDEN, true);
}

void CreateText(string name, datetime time, double price, string text, color clr, int font_size = 10)
{
   name = PREFIX + name;
   
   if(ObjExists(name))
   {
      ObjectSetString(0, name, OBJPROP_TEXT, text);
      ObjectSetInteger(0, name, OBJPROP_COLOR, clr);
      ObjectSetInteger(0, name, OBJPROP_FONTSIZE, font_size);
   }
   else
   {
      if(ObjectCreate(0, name, OBJ_TEXT, 0, time, price))
      {
         ObjectSetString(0, name, OBJPROP_TEXT, text);
         ObjectSetInteger(0, name, OBJPROP_COLOR, clr);
         ObjectSetInteger(0, name, OBJPROP_FONTSIZE, font_size);
         ObjectSetInteger(0, name, OBJPROP_BACK, false);
         ObjectSetInteger(0, name, OBJPROP_SELECTABLE, false);
         ObjectSetInteger(0, name, OBJPROP_HIDDEN, true);
      }
   }
}

string FormatPrice(double price)
{
   int digits = (int)SymbolInfoInteger(_Symbol, SYMBOL_DIGITS);
   return DoubleToString(price, digits);
}

bool IsNewCandle()
{
   static datetime last_time = 0;
   datetime current_time = iTime(_Symbol, _Period, 0);
   
   if(current_time != last_time)
   {
      last_time = current_time;
      return true;
   }
   return false;
}

//‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
//‚ñà  SEC√á√ÉO 4: GEST√ÉO DE INDICADORES                                ‚ñà
//‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà

bool BuildHandlesForTF(ENUM_TIMEFRAMES chart_tf)
{
   if(handle_sma_chart == INVALID_HANDLE)
      handle_sma_chart = iMA(_Symbol, chart_tf, SMA_PERIOD, 0, MODE_SMA, PRICE_CLOSE);
   
   if(handle_rsi_chart == INVALID_HANDLE)
      handle_rsi_chart = iRSI(_Symbol, chart_tf, RSI_PERIOD, PRICE_CLOSE);
   
   if(handle_ema_20 == INVALID_HANDLE)
      handle_ema_20 = iMA(_Symbol, chart_tf, 20, 0, MODE_EMA, PRICE_CLOSE);
   
   if(handle_ema_50 == INVALID_HANDLE)
      handle_ema_50 = iMA(_Symbol, chart_tf, 50, 0, MODE_EMA, PRICE_CLOSE);
   
   if(handle_atr == INVALID_HANDLE)
      handle_atr = iATR(_Symbol, chart_tf, 14);

   if(handle_sma_chart == INVALID_HANDLE || handle_rsi_chart == INVALID_HANDLE)
   {
      Print("Erro: Falha ao criar handles dos indicadores");
      return false;
   }
   
   return true;
}

bool ReadOne(int handle, double &out_val, int shift=0)
{
   if(handle == INVALID_HANDLE) 
      return false;
      
   double buf[];
   if(CopyBuffer(handle, 0, shift, 1, buf) <= 0)
      return false;
      
   out_val = buf[0];
   return true;
}

//‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
//‚ñà  SEC√á√ÉO 5: AN√ÅLISE DE TEND√äNCIA                                 ‚ñà
//‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà

int IdentifyTrend(ENUM_TIMEFRAMES tf_chart, double price_current)
{
   double ema20, ema50, sma200;
   
   if(!ReadOne(handle_ema_20, ema20, 0) || !ReadOne(handle_ema_50, ema50, 0) || !ReadOne(handle_sma_chart, sma200, 0)) 
      return 0;
   
   int trend_score = 0;
   
   if(price_current > ema20) trend_score++;
   if(ema20 > ema50) trend_score++;
   if(ema50 > sma200) trend_score++;
   if(price_current > sma200) trend_score++;
   
   if(trend_score >= 3) return 1;
   if(trend_score <= 1) return -1;
   
   return 0;
}

//‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
//‚ñà  SEC√á√ÉO 6: SISTEMA SIMPLIFICADO DE SUPORTE E RESIST√äNCIA       ‚ñà
//‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà

bool CalculateSmartSupportResistance(ENUM_TIMEFRAMES tf, double &support, double &resistance, int &support_touches, int &resistance_touches)
{
   MqlRates rates[];
   int copied = CopyRates(_Symbol, tf, 0, SR_CANDLES, rates);
   
   if(copied < SR_CANDLES) 
   {
      Print("‚ùå Dados insuficientes para S/R: " + IntegerToString(copied) + " velas");
      return false;
   }
   
   // M√©todo simples: encontrar m√≠nimos e m√°ximos significativos
   double lows[], highs[];
   ArrayResize(lows, copied);
   ArrayResize(highs, copied);
   
   for(int i = 0; i < copied; i++)
   {
      lows[i] = rates[i].low;
      highs[i] = rates[i].high;
   }
   
   // Encontrar clusters de pre√ßo para suporte e resist√™ncia
   support = FindSignificantLevel(lows, copied, true);
   resistance = FindSignificantLevel(highs, copied, false);
   
   // Verificar se os n√≠veis s√£o v√°lidos
   double current_price = SymbolInfoDouble(_Symbol, SYMBOL_BID);
   double atr_value = 0;
   ReadOne(handle_atr, atr_value);
   double min_distance = atr_value * 0.5;
   
   bool valid_support = (support > 0 && MathAbs(current_price - support) > min_distance);
   bool valid_resistance = (resistance > 0 && MathAbs(current_price - resistance) > min_distance);
   
   if(valid_support && valid_resistance)
   {
      support_touches = 3;
      resistance_touches = 3;
      
      Print("‚úÖ S/R SIMPLES: Suporte=" + FormatPrice(support) + 
            " | Resist√™ncia=" + FormatPrice(resistance) + 
            " | Dist√¢ncia=" + DoubleToString(MathAbs(resistance - support)/_Point, 0) + " pontos");
      
      return true;
   }
   
   return false;
}

double FindSignificantLevel(double &prices[], int count, bool is_support)
{
   if(count == 0) return 0;
   
   // Ordenar os pre√ßos
   ArraySort(prices);
   
   // Encontrar o cluster mais significativo
   double threshold = 50 * _Point; // 5 pips de toler√¢ncia
   int max_cluster_size = 0;
   double best_level = prices[0];
   
   for(int i = 0; i < count; i++)
   {
      int cluster_size = 0;
      double cluster_sum = 0;
      
      for(int j = 0; j < count; j++)
      {
         if(MathAbs(prices[i] - prices[j]) <= threshold)
         {
            cluster_size++;
            cluster_sum += prices[j];
         }
      }
      
      if(cluster_size > max_cluster_size)
      {
         max_cluster_size = cluster_size;
         best_level = cluster_sum / cluster_size;
      }
   }
   
   // Apenas retornar se encontrou um cluster significativo
   if(max_cluster_size >= 2)
   {
      return NormalizeDouble(best_level, _Digits);
   }
   
   return 0;
}

bool IsNearStrongSR(double price, double sr_level, int touch_count, string level_type)
{
   if(sr_level == 0) return false;
   
   double distance_pips = MathAbs(price - sr_level) / (_Point * 10);
   bool is_near = (distance_pips <= 15.0); // 15 pips de toler√¢ncia
   
   if(is_near)
   {
      Print("üéØ " + level_type + " PR√ìXIMO: " + FormatPrice(sr_level) + 
            " | Dist√¢ncia: " + DoubleToString(distance_pips, 1) + " pips");
   }
   
   return is_near;
}

//‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
//‚ñà  SEC√á√ÉO 7: FIBONACCI FUNCTIONS (CORRE√á√ÉO DEFINITIVA)          ‚ñà
//‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà

bool IsFibonacciActive(double price, double fib_50, double fib_618, int trend_direction)
{
   if(trend_direction == 0) 
   {
      Print("‚ùå Fibonacci INATIVO - Tend√™ncia lateral");
      return false;
   }
   
   // ‚úÖ‚úÖ‚úÖ VERIFICA√á√ÉO ESTRITA: CONFLU√äNCIA ATIVA APENAS ENTRE 50% E 61.8% (INCLUSIVE)
   if(trend_direction == 1) // TEND√äNCIA DE ALTA
   {
      bool above_50 = (price >= fib_50);
      bool below_618 = (price <= fib_618);
      bool in_golden_zone = (above_50 && below_618);
      
      Print("=== VERIFICA√á√ÉO FIBONACCI ALTA ===");
      Print("Pre√ßo: ", FormatPrice(price));
      Print("50%: ", FormatPrice(fib_50), " | Acima de 50%: ", above_50 ? "SIM" : "N√ÉO");
      Print("61.8%: ", FormatPrice(fib_618), " | Abaixo de 61.8%: ", below_618 ? "SIM" : "N√ÉO");
      Print("Zona 50%-61.8%: ", in_golden_zone ? "DENTRO" : "FORA");
      
      // ‚úÖ‚úÖ‚úÖ VERIFICA√á√ÉO EXTRA: Dist√¢ncia exata
      double distance_to_50 = price - fib_50;
      double distance_to_618 = fib_618 - price;
      
      Print("Dist√¢ncia at√© 50%: ", FormatPrice(distance_to_50));
      Print("Dist√¢ncia at√© 61.8%: ", FormatPrice(distance_to_618));
      
      if(in_golden_zone)
      {
         Print("‚úÖ‚úÖ‚úÖ FIBONACCI GOLDEN ZONE ATIVA - Pre√ßo na ZONA 50%-61.8%");
         return true;
      }
      else
      {
         if(price < fib_50)
            Print("‚ùå‚ùå‚ùå Fibonacci INATIVO - Pre√ßo ABAIXO de 50% (", FormatPrice(price - fib_50), " pontos)");
         else if(price > fib_618)
            Print("‚ùå‚ùå‚ùå Fibonacci INATIVO - Pre√ßo ACIMA de 61.8% (", FormatPrice(price - fib_618), " pontos)");
         return false;
      }
   }
   else if(trend_direction == -1) // TEND√äNCIA DE BAIXA
   {
      bool below_50 = (price <= fib_50);
      bool above_618 = (price >= fib_618);
      bool in_golden_zone = (below_50 && above_618);
      
      Print("=== VERIFICA√á√ÉO FIBONACCI BAIXA ===");
      Print("Pre√ßo: ", FormatPrice(price));
      Print("50%: ", FormatPrice(fib_50), " | Abaixo de 50%: ", below_50 ? "SIM" : "N√ÉO");
      Print("61.8%: ", FormatPrice(fib_618), " | Acima de 61.8%: ", above_618 ? "SIM" : "N√ÉO");
      Print("Zona 50%-61.8%: ", in_golden_zone ? "DENTRO" : "FORA");
      
      // ‚úÖ‚úÖ‚úÖ VERIFICA√á√ÉO EXTRA: Dist√¢ncia exata
      double distance_to_50 = fib_50 - price;
      double distance_to_618 = price - fib_618;
      
      Print("Dist√¢ncia at√© 50%: ", FormatPrice(distance_to_50));
      Print("Dist√¢ncia at√© 61.8%: ", FormatPrice(distance_to_618));
      
      if(in_golden_zone)
      {
         Print("‚úÖ‚úÖ‚úÖ FIBONACCI GOLDEN ZONE ATIVA - Pre√ßo na ZONA 50%-61.8%");
         return true;
      }
      else
      {
         if(price > fib_50)
            Print("‚ùå‚ùå‚ùå Fibonacci INATIVO - Pre√ßo ACIMA de 50% (", FormatPrice(price - fib_50), " pontos)");
         else if(price < fib_618)
            Print("‚ùå‚ùå‚ùå Fibonacci INATIVO - Pre√ßo ABAIXO de 61.8% (", FormatPrice(fib_618 - price), " pontos)");
         return false;
      }
   }
   
   return false;
}

bool ShouldRemoveFibonacci(double price, double fib_0, double fib_100, int trend_direction)
{
   if(trend_direction == 0) 
   {
      Print("üî¥ REMOVER FIBO - Tend√™ncia lateral");
      return true;
   }
   
   double range = MathAbs(fib_100 - fib_0);
   double fib_45, fib_65;
   
   if(trend_direction == 1) // ALTA
   {
      fib_45 = fib_0 + (range * 0.45);
      fib_65 = fib_0 + (range * 0.65);
      
      bool remove_below_45 = (price < fib_45);
      bool remove_above_65 = (price > fib_65);
      
      Print("=== VERIFICA√á√ÉO REMO√á√ÉO FIBO ALTA ===");
      Print("Pre√ßo: ", FormatPrice(price));
      Print("45%: ", FormatPrice(fib_45), " | Abaixo de 45%: ", remove_below_45 ? "SIM" : "N√ÉO");
      Print("65%: ", FormatPrice(fib_65), " | Acima de 65%: ", remove_above_65 ? "SIM" : "N√ÉO");
      
      if(remove_below_45)
      {
         Print("üî¥üî¥üî¥ REMOVER FIBO - Pre√ßo ABAIXO de 45% em ALTA");
         return true;
      }
      else if(remove_above_65)
      {
         Print("üî¥üî¥üî¥ REMOVER FIBO - Pre√ßo ACIMA de 65% em ALTA");
         return true;
      }
   }
   else if(trend_direction == -1) // BAIXA
   {
      fib_45 = fib_0 - (range * 0.45);
      fib_65 = fib_0 - (range * 0.65);
      
      bool remove_above_45 = (price > fib_45);
      bool remove_below_65 = (price < fib_65);
      
      Print("=== VERIFICA√á√ÉO REMO√á√ÉO FIBO BAIXA ===");
      Print("Pre√ßo: ", FormatPrice(price));
      Print("45%: ", FormatPrice(fib_45), " | Acima de 45%: ", remove_above_45 ? "SIM" : "N√ÉO");
      Print("65%: ", FormatPrice(fib_65), " | Abaixo de 65%: ", remove_below_65 ? "SIM" : "N√ÉO");
      
      if(remove_above_45)
      {
         Print("üî¥üî¥üî¥ REMOVER FIBO - Pre√ßo ACIMA de 45% em BAIXA");
         return true;
      }
      else if(remove_below_65)
      {
         Print("üî¥üî¥üî¥ REMOVER FIBO - Pre√ßo ABAIXO de 65% em BAIXA");
         return true;
      }
   }
   
   Print("‚úÖ MANTER FIBO - Pre√ßo dentro dos limites 45%-65%");
   return false;
}

bool ComputeFibLevels(ENUM_TIMEFRAMES tf, int trend_direction, double &fib_0, double &fib_50, double &fib_618, double &fib_100, double &fib_786, double &fib_382)
{
   if(trend_direction == 0)
   {
      Print("Fibonacci BLOQUEADO - Tend√™ncia lateral");
      return false;
   }
   
   MqlRates rates[];
   int copied = CopyRates(_Symbol, tf, 0, 50, rates);
   if(copied < 20) 
      return false;
   
   double swing_high = rates[0].high;
   double swing_low = rates[0].low;
   datetime swing_high_time = rates[0].time;
   datetime swing_low_time = rates[0].time;
   
   for(int i = 1; i < copied; i++)
   {
      if(rates[i].high > swing_high)
      {
         swing_high = rates[i].high;
         swing_high_time = rates[i].time;
      }
      if(rates[i].low < swing_low)
      {
         swing_low = rates[i].low;
         swing_low_time = rates[i].time;
      }
   }
   
   if(trend_direction == 1) // TEND√äNCIA DE ALTA
   {
      fib_start_price = swing_low;
      fib_end_price = swing_high;
      fib_start_time = swing_low_time;
      fib_end_time = swing_high_time;
   }
   else // TEND√äNCIA DE BAIXA
   {
      fib_start_price = swing_high;
      fib_end_price = swing_low;
      fib_start_time = swing_high_time;
      fib_end_time = swing_low_time;
   }
   
   if(fib_start_time > fib_end_time)
   {
      double temp_price = fib_start_price;
      datetime temp_time = fib_start_time;
      fib_start_price = fib_end_price;
      fib_start_time = fib_end_time;
      fib_end_price = temp_price;
      fib_end_time = temp_time;
   }
   
   double atr_value = 0;
   ReadOne(handle_atr, atr_value);
   double min_move = atr_value * 0.5;
   
   if(MathAbs(fib_end_price - fib_start_price) < min_move)
      return false;
   
   double range = MathAbs(fib_end_price - fib_start_price);
   
   if(trend_direction == 1)
   {
      fib_0 = fib_start_price;
      fib_100 = fib_end_price;
      fib_382 = fib_start_price + (range * 0.382);
      fib_50 = fib_start_price + (range * 0.5);
      fib_618 = fib_start_price + (range * 0.618);
      fib_786 = fib_start_price + (range * 0.786);
   }
   else
   {
      fib_0 = fib_start_price;
      fib_100 = fib_end_price;
      fib_382 = fib_start_price - (range * 0.382);
      fib_50 = fib_start_price - (range * 0.5);
      fib_618 = fib_start_price - (range * 0.618);
      fib_786 = fib_start_price - (range * 0.786);
   }
   
   Print("üéØ FIBONACCI CALCULADO - Tend√™ncia: ", (trend_direction == 1 ? "ALTA" : "BAIXA"));
   Print("0%: ", FormatPrice(fib_0), " | 38.2%: ", FormatPrice(fib_382), " | 50%: ", FormatPrice(fib_50));
   Print("61.8%: ", FormatPrice(fib_618), " | 78.6%: ", FormatPrice(fib_786), " | 100%: ", FormatPrice(fib_100));
   
   // Calcular e mostrar tamb√©m os n√≠veis de 45% e 65% para remo√ß√£o
   double fib_45, fib_65;
   if(trend_direction == 1)
   {
      fib_45 = fib_start_price + (range * 0.45);
      fib_65 = fib_start_price + (range * 0.65);
   }
   else
   {
      fib_45 = fib_start_price - (range * 0.45);
      fib_65 = fib_start_price - (range * 0.65);
   }
   Print("45% (remo√ß√£o): ", FormatPrice(fib_45), " | 65% (remo√ß√£o): ", FormatPrice(fib_65));
   
   return true;
}

void DrawFibonacciLevels(double fib_0, double fib_50, double fib_618, double fib_100, int trend_direction)
{
   string fib_name = PREFIX + "FIB_MAIN";
   
   if(ObjExists(fib_name))
      ObjectDelete(0, fib_name);
   
   if(fib_start_time == 0 || fib_end_time == 0)
      return;
   
   if(fib_start_price == 0 || fib_end_price == 0)
      return;
   
   Print("üéØ DESENHANDO FIBONACCI - Fibonacci Golden Zone (50%-61.8%)");
   
   if(ObjectCreate(0, fib_name, OBJ_FIBO, 0, fib_start_time, fib_start_price, fib_end_time, fib_end_price))
   {
      color fib_color = clrLightGray;
      
      ObjectSetInteger(0, fib_name, OBJPROP_COLOR, fib_color);
      ObjectSetInteger(0, fib_name, OBJPROP_STYLE, STYLE_SOLID);
      ObjectSetInteger(0, fib_name, OBJPROP_WIDTH, 1);
      ObjectSetInteger(0, fib_name, OBJPROP_BACK, true);
      ObjectSetInteger(0, fib_name, OBJPROP_SELECTABLE, false);
      ObjectSetInteger(0, fib_name, OBJPROP_RAY_RIGHT, true);
      
      // Apenas 4 n√≠veis: 0%, 50%, 61.8%, 100%
      ObjectSetInteger(0, fib_name, OBJPROP_LEVELS, 4);
      
      // N√≠vel 0.0 (0%)
      ObjectSetInteger(0, fib_name, OBJPROP_LEVELCOLOR, 0, fib_color);
      ObjectSetInteger(0, fib_name, OBJPROP_LEVELSTYLE, 0, STYLE_SOLID);
      ObjectSetInteger(0, fib_name, OBJPROP_LEVELWIDTH, 0, 1);
      ObjectSetDouble(0, fib_name, OBJPROP_LEVELVALUE, 0, 0.0);
      ObjectSetString(0, fib_name, OBJPROP_LEVELTEXT, 0, "0%");
      
      // N√≠vel 0.5 (50%) - GOLDEN ZONE
      ObjectSetInteger(0, fib_name, OBJPROP_LEVELCOLOR, 1, fib_color);
      ObjectSetInteger(0, fib_name, OBJPROP_LEVELSTYLE, 1, STYLE_SOLID);
      ObjectSetInteger(0, fib_name, OBJPROP_LEVELWIDTH, 1, 1);
      ObjectSetDouble(0, fib_name, OBJPROP_LEVELVALUE, 1, 0.5);
      ObjectSetString(0, fib_name, OBJPROP_LEVELTEXT, 1, "50%");
      
      // N√≠vel 0.618 (61.8%) - GOLDEN ZONE
      ObjectSetInteger(0, fib_name, OBJPROP_LEVELCOLOR, 2, fib_color);
      ObjectSetInteger(0, fib_name, OBJPROP_LEVELSTYLE, 2, STYLE_SOLID);
      ObjectSetInteger(0, fib_name, OBJPROP_LEVELWIDTH, 2, 1);
      ObjectSetDouble(0, fib_name, OBJPROP_LEVELVALUE, 2, 0.618);
      ObjectSetString(0, fib_name, OBJPROP_LEVELTEXT, 2, "61.8%");
      
      // N√≠vel 1.0 (100%)
      ObjectSetInteger(0, fib_name, OBJPROP_LEVELCOLOR, 3, fib_color);
      ObjectSetInteger(0, fib_name, OBJPROP_LEVELSTYLE, 3, STYLE_SOLID);
      ObjectSetInteger(0, fib_name, OBJPROP_LEVELWIDTH, 3, 1);
      ObjectSetDouble(0, fib_name, OBJPROP_LEVELVALUE, 3, 1.0);
      ObjectSetString(0, fib_name, OBJPROP_LEVELTEXT, 3, "100%");
      
      fib_drawn = true;
      Print("‚úÖ‚úÖ‚úÖ FIBONACCI DESENHADO - Fibonacci Golden Zone (50%-61.8%)");
   }
}

void ClearFibonacciLevels()
{
   string fib_name = PREFIX + "FIB_MAIN";
   if(ObjExists(fib_name))
   {
      ObjectDelete(0, fib_name);
      fib_drawn = false;
      Print("üóëÔ∏èüóëÔ∏èüóëÔ∏è Fibonacci REMOVIDO do gr√°fico");
   }
}

//‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
//‚ñà  FUN√á√ÉO: GEST√ÉO COMPLETA DO FIBONACCI (CORRE√á√ÉO DEFINITIVA)   ‚ñà
//‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà

bool ManageFibonacciComplete(ENUM_TIMEFRAMES tf, double price, int trend_direction, bool &fib_active_out)
{
   if(!SHOW_FIBONACCI || trend_direction == 0)
   {
      ClearFibonacciLevels();
      fib_active_out = false;
      return false;
   }
   
   double fib_0 = 0, fib_50 = 0, fib_618 = 0, fib_100 = 0, fib_786 = 0, fib_382 = 0;
   
   // ‚úÖ SEMPRE recalcular os n√≠veis para garantir precis√£o
   bool fib_calculated = ComputeFibLevels(tf, trend_direction, fib_0, fib_50, fib_618, fib_100, fib_786, fib_382);
   
   if(!fib_calculated)
   {
      ClearFibonacciLevels();
      fib_active_out = false;
      return false;
   }
   
   // ‚úÖ VERIFICA√á√ÉO 1: Remover Fibonacci se pre√ßo ultrapassar 45% ou 65%
   bool should_remove = ShouldRemoveFibonacci(price, fib_0, fib_100, trend_direction);
   
   if(should_remove)
   {
      ClearFibonacciLevels();
      fib_active_out = false;
      Print("üî¥üî¥üî¥ FIBONACCI REMOVIDO - Pre√ßo fora dos limites 45%-65%");
      return false;
   }
   
   // ‚úÖ VERIFICA√á√ÉO 2: Desenhar/Manter Fibonacci no gr√°fico
   if(!fib_drawn)
   {
      DrawFibonacciLevels(fib_0, fib_50, fib_618, fib_100, trend_direction);
   }
   
   // ‚úÖ‚úÖ‚úÖ VERIFICA√á√ÉO 3: Conflu√™ncia ativa APENAS entre 50% e 61.8% (VERIFICA√á√ÉO ESTRITA)
   fib_active_out = IsFibonacciActive(price, fib_50, fib_618, trend_direction);
   
   // ‚úÖ LOG DETALHADO
   Print("=== STATUS FIBONACCI FINAL ===");
   Print("Fibonacci Desenhado: ", fib_drawn);
   Print("Conflu√™ncia Ativa: ", fib_active_out);
   Print("Pre√ßo: ", FormatPrice(price));
   Print("50%: ", FormatPrice(fib_50));
   Print("61.8%: ", FormatPrice(fib_618));
   
   if(fib_active_out)
   {
      Print("‚úÖ‚úÖ‚úÖ FIBONACCI GOLDEN ZONE - Conflu√™ncia ATIVA (Pre√ßo entre 50%-61.8%)");
   }
   else
   {
      Print("‚ùå‚ùå‚ùå FIBONACCI INATIVO - Pre√ßo FORA da Zona 50%-61.8%");
   }
   
   return fib_drawn;
}

//‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
//‚ñà  SEC√á√ÉO 8: PRICE ACTION (ATUALIZADA 2024 - CORRE√á√ïES CR√çTICAS) ‚ñà
//‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà

bool IsDoji(const MqlRates &rate)
{
   double body = MathAbs(rate.close - rate.open);
   double range = rate.high - rate.low;
   if(range == 0) return false;
   double body_ratio = body / range;
   return (body_ratio < 0.1);
}

bool IsValidMarubozu(const MqlRates &candle, bool is_bullish)
{
   double body = MathAbs(candle.close - candle.open);
   double upper_wick = candle.high - MathMax(candle.open, candle.close);
   double lower_wick = MathMin(candle.open, candle.close) - candle.low;
   double range = candle.high - candle.low;
   if(range <= 0) return false;
   
   double body_ratio = body / range;
   bool small_wicks = (upper_wick / range) < 0.1 && (lower_wick / range) < 0.1;
   
   bool is_large_body = body_ratio >= 0.8; 
   
   if(is_bullish)
   {
      return (candle.close > candle.open) && is_large_body && small_wicks;
   }
   else 
   {
      return (candle.close < candle.open) && is_large_body && small_wicks;
   }
}

bool IsValidHammer(const MqlRates &candle, int trend_direction) 
{
   double body = MathAbs(candle.close - candle.open);
   double upper_wick = candle.high - MathMax(candle.open, candle.close);
   double lower_wick = MathMin(candle.open, candle.close) - candle.low;
   double range = candle.high - candle.low;
   if(range <= 0) return false;
   
   bool small_body = body / range <= 0.3;
   bool long_lower_wick = lower_wick >= body * 2.0; 
   bool tiny_upper_wick = upper_wick / range <= 0.1; 
   
   if (trend_direction == -1) 
   {
      return small_body && long_lower_wick && tiny_upper_wick;
   }
   return false;
}

bool IsValidHangingMan(const MqlRates &candle, int trend_direction) 
{
   double body = MathAbs(candle.close - candle.open);
   double upper_wick = candle.high - MathMax(candle.open, candle.close);
   double lower_wick = MathMin(candle.open, candle.close) - candle.low;
   double range = candle.high - candle.low;
   if(range <= 0) return false;
   
   bool small_body = body / range <= 0.3;
   bool long_lower_wick = lower_wick >= body * 2.0;
   bool tiny_upper_wick = upper_wick / range <= 0.1;
   
   if (trend_direction == 1) 
   {
      return small_body && long_lower_wick && tiny_upper_wick;
   }
   return false;
}

bool IsValidShootingStar(const MqlRates &candle, int trend_direction) 
{
   double body = MathAbs(candle.close - candle.open);
   double upper_wick = candle.high - MathMax(candle.open, candle.close);
   double lower_wick = MathMin(candle.open, candle.close) - candle.low;
   double range = candle.high - candle.low;
   if(range <= 0) return false;
   
   bool small_body = body / range <= 0.3;
   bool long_upper_wick = upper_wick >= body * 2.0; 
   bool tiny_lower_wick = lower_wick / range <= 0.1; 
   
   if (trend_direction == 1) 
   {
      return small_body && long_upper_wick && tiny_lower_wick;
   }
   return false;
}

bool IsValidInvertedHammer(const MqlRates &candle, int trend_direction) 
{
   double body = MathAbs(candle.close - candle.open);
   double upper_wick = candle.high - MathMax(candle.open, candle.close);
   double lower_wick = MathMin(candle.open, candle.close) - candle.low;
   double range = candle.high - candle.low;
   if(range <= 0) return false;
   
   bool small_body = body / range <= 0.3;
   bool long_upper_wick = upper_wick >= body * 2.0;
   bool tiny_lower_wick = lower_wick / range <= 0.1;
   
   if (trend_direction == -1) 
   {
      return small_body && long_upper_wick && tiny_lower_wick;
   }
   return false;
}

// ‚úÖ **BULLISH ENGULFING CORRETO: Primeira vela BAIXA, Segunda vela ALTA QUE ENGOLFE COMPLETAMENTE**
bool IsValidBullishEngulfing(const MqlRates &current_CLOSED, const MqlRates &previous_CLOSED)
{
   // üî¥ VELA ANTERIOR FECHADA: DEVE SER BEARISH (vermelha) - PRIMEIRA VELA
   if(previous_CLOSED.close >= previous_CLOSED.open) 
   {
      Print("‚ùå Bullish Engulfing: Vela anterior n√£o √© bearish");
      return false;
   }
   
   // üü¢ VELA ATUAL FECHADA: DEVE SER BULLISH (verde) - SEGUNDA VELA
   if(current_CLOSED.close <= current_CLOSED.open) 
   {
      Print("‚ùå Bullish Engulfing: Vela atual n√£o √© bullish");
      return false;
   }
   
   // ‚úÖ CONDI√á√ÉO 1: Abertura atual < Fechamento anterior (MAIS RESTRITIVO)
   if(current_CLOSED.open >= previous_CLOSED.close) 
   {
      Print("‚ùå Bullish Engulfing: Abertura atual >= Fechamento anterior");
      return false;
   }
   
   // ‚úÖ CONDI√á√ÉO 2: Fechamento atual > Abertura anterior (MAIS RESTRITIVO)
   if(current_CLOSED.close <= previous_CLOSED.open) 
   {
      Print("‚ùå Bullish Engulfing: Fechamento atual <= Abertura anterior");
      return false;
   }

   Print("‚úÖ‚úÖ‚úÖ BULLISH ENGULFING CONFIRMADO:");
   Print("   Vela1 (Bearish): Abertura=" + FormatPrice(previous_CLOSED.open) + " Fecho=" + FormatPrice(previous_CLOSED.close));
   Print("   Vela2 (Bullish): Abertura=" + FormatPrice(current_CLOSED.open) + " Fecho=" + FormatPrice(current_CLOSED.close));
   Print("   Engulfing: " + FormatPrice(current_CLOSED.open) + " < " + FormatPrice(previous_CLOSED.close) + 
         " && " + FormatPrice(current_CLOSED.close) + " > " + FormatPrice(previous_CLOSED.open));
   
   return true;
}

// ‚úÖ **BEARISH ENGULFING CORRETO: Primeira vela ALTA, Segunda vela BAIXA QUE ENGOLFE COMPLETAMENTE**
bool IsValidBearishEngulfing(const MqlRates &current_CLOSED, const MqlRates &previous_CLOSED)
{
   // üü¢ VELA ANTERIOR FECHADA: DEVE SER BULLISH (verde) - PRIMEIRA VELA
   if(previous_CLOSED.close <= previous_CLOSED.open) 
   {
      Print("‚ùå Bearish Engulfing: Vela anterior n√£o √© bullish");
      return false;
   }
   
   // üî¥ VELA ATUAL FECHADA: DEVE SER BEARISH (vermelha) - SEGUNDA VELA
   if(current_CLOSED.close >= current_CLOSED.open) 
   {
      Print("‚ùå Bearish Engulfing: Vela atual n√£o √© bearish");
      return false;
   }
   
   // ‚úÖ CONDI√á√ÉO 1: Abertura atual > Fechamento anterior (MAIS RESTRITIVO)
   if(current_CLOSED.open <= previous_CLOSED.close) 
   {
      Print("‚ùå Bearish Engulfing: Abertura atual <= Fechamento anterior");
      return false;
   }
   
   // ‚úÖ CONDI√á√ÉO 2: Fechamento atual < Abertura anterior (MAIS RESTRITIVO)
   if(current_CLOSED.close >= previous_CLOSED.open) 
   {
      Print("‚ùå Bearish Engulfing: Fechamento atual >= Abertura anterior");
      return false;
   }

   Print("‚úÖ‚úÖ‚úÖ BEARISH ENGULFING CONFIRMADO:");
   Print("   Vela1 (Bullish): Abertura=" + FormatPrice(previous_CLOSED.open) + " Fecho=" + FormatPrice(previous_CLOSED.close));
   Print("   Vela2 (Bearish): Abertura=" + FormatPrice(current_CLOSED.open) + " Fecho=" + FormatPrice(current_CLOSED.close));
   Print("   Engulfing: " + FormatPrice(current_CLOSED.open) + " > " + FormatPrice(previous_CLOSED.close) + 
         " && " + FormatPrice(current_CLOSED.close) + " < " + FormatPrice(previous_CLOSED.open));
   
   return true;
}

bool IsValidPiercingLine(const MqlRates &current, const MqlRates &previous) 
{
   // Vela anterior deve ser bearish
   if(previous.close >= previous.open) return false;
   
   // Vela atual deve ser bullish
   if(current.close <= current.open) return false;
   
   // Abertura atual deve estar abaixo do fecho anterior
   if(current.open >= previous.close) return false;
   
   // Fecho atual deve estar acima do ponto m√©dio da vela anterior
   double midpoint_previous = (previous.open + previous.close) / 2.0;
   if(current.close <= midpoint_previous) return false;
   
   return true;
}

bool IsValidDarkCloudCover(const MqlRates &current, const MqlRates &previous) 
{
   // Vela anterior deve ser bullish
   if(previous.close <= previous.open) return false;
   
   // Vela atual deve ser bearish
   if(current.close >= current.open) return false;
   
   // Abertura atual deve estar acima do fecho anterior
   if(current.open <= previous.close) return false;
   
   // Fecho atual deve estar abaixo do ponto m√©dio da vela anterior
   double midpoint_previous = (previous.open + previous.close) / 2.0;
   if(current.close >= midpoint_previous) return false;
   
   return true;
}

bool IsValidThreeWhiteSoldiers(MqlRates &rates[], int count) 
{
   if(count < 3) return false;

   // Verificar se todas as 3 velas s√£o bullish
   for(int i = 0; i < 3; i++)
   {
      if(rates[i].close <= rates[i].open) return false;
   }

   // Verificar progress√£o: cada vela abre dentro do corpo da anterior e fecha mais alto
   if(rates[0].open >= rates[1].open || rates[0].close >= rates[1].close) return false;
   if(rates[1].open >= rates[2].open || rates[1].close >= rates[2].close) return false;

   return true;
}

bool IsValidThreeBlackCrows(MqlRates &rates[], int count) 
{
   if(count < 3) return false;

   // Verificar se todas as 3 velas s√£o bearish
   for(int i = 0; i < 3; i++)
   {
      if(rates[i].close >= rates[i].open) return false;
   }

   // Verificar progress√£o: cada vela abre dentro do corpo da anterior e fecha mais baixo
   if(rates[0].open <= rates[1].open || rates[0].close <= rates[1].close) return false;
   if(rates[1].open <= rates[2].open || rates[1].close <= rates[2].close) return false;

   return true;
}

void ClearPriceActionMarkers()
{
   int total = ObjectsTotal(0);
   for(int i = total-1; i >= 0; i--)
   {
      string name = ObjectName(0, i);
      if(StringFind(name, PREFIX + "PA_") == 0)
      {
         ObjectDelete(0, name);
      }
   }
}

void DrawPriceActionNumber(int graph_position, string number_text, color clr, int trend_direction)
{
   string name = PREFIX + "PA_" + IntegerToString(graph_position) + "_" + number_text;
   datetime time = iTime(_Symbol, _Period, graph_position);
   
   // ‚úÖ CALCULAR POSI√á√ÉO CORRETA CONFORMA TEND√äNCIA
   double number_price;
   
   if(trend_direction == 1) // TEND√äNCIA DE ALTA
   {
      // N√∫mero ACIMA da vela (no topo)
      number_price = iHigh(_Symbol, _Period, graph_position) + (40 * _Point);
   }
   else if(trend_direction == -1) // TEND√äNCIA DE BAIXA
   {
      // N√∫mero ABAIXO da vela (na base)
      number_price = iLow(_Symbol, _Period, graph_position) - (40 * _Point);
   }
   else // TEND√äNCIA LATERAL
   {
      // N√∫mero ACIMA da vela (padr√£o)
      number_price = iHigh(_Symbol, _Period, graph_position) + (40 * _Point);
   }
   
   if(ObjectCreate(0, name, OBJ_TEXT, 0, time, number_price))
   {
      ObjectSetString(0, name, OBJPROP_TEXT, number_text);
      ObjectSetInteger(0, name, OBJPROP_COLOR, clr);
      ObjectSetInteger(0, name, OBJPROP_FONTSIZE, 10);
      ObjectSetInteger(0, name, OBJPROP_BACK, false);
      ObjectSetInteger(0, name, OBJPROP_SELECTABLE, false);
      ObjectSetInteger(0, name, OBJPROP_HIDDEN, true);
   }
}

int DetectPriceActionPattern(MqlRates &rates[], int count, ENUM_TIMEFRAMES tf)
{
   // ‚úÖ Analisar APENAS as 3 √∫ltimas velas FECHADAS
   if(count < 3) 
   {
      Print("‚ùå Dados insuficientes para an√°lise PA: " + IntegerToString(count) + " velas fechadas");
      return 0;
   }
   
   Print("üîç ANALISANDO PRICE ACTION - 3 √öLTIMAS VELAS FECHADAS");
   
   // ‚úÖ DECLARAR VARI√ÅVEIS CORRETAMENTE
   MqlRates vela1 = rates[0]; // Vela MAIS RECENTE FECHADA (Posi√ß√£o 1 no gr√°fico)
   MqlRates vela2 = rates[1]; // 2¬™ vela FECHADA (Posi√ß√£o 2 no gr√°fico)  
   MqlRates vela3 = rates[2]; // 3¬™ vela FECHADA (Posi√ß√£o 3 no gr√°fico)
   
   // Verificar se √© Doji primeiro (ignorar)
   if(IsDoji(vela1))
   {
      Print("‚ö™ Doji detetado na Vela1 (mais recente) - ignorando");
      return 0;
   }
   
   pa_bullish = false;
   pa_bearish = false;
   
   // ‚úÖ IDENTIFICAR TEND√äNCIA ATUAL
   int current_trend = IdentifyTrend(tf, vela1.close);
   Print("üìä Tend√™ncia atual: " + (current_trend == 1 ? "ALTA" : (current_trend == -1 ? "BAIXA" : "LATERAL")));
   
   // ‚úÖ PADR√ïES DE 1 VELA (Vela1 FECHADA)
   Print("üéØ Analisando padr√µes de 1 vela na Vela1 FECHADA...");
   
   // Padr√µes Bullish de 1 vela na Vela1 FECHADA
   if(IsValidHammer(vela1, current_trend))
   {
      pa_current_pattern = 1; 
      pa_current_description = "Martelo"; 
      pa_current_color = COL_CONTRA_TREND;
      DrawPriceActionNumber(1, "1", pa_current_color, current_trend);
      pa_bullish = true; 
      Print("‚úÖ Martelo Bullish confirmado na Vela1 FECHADA (Posi√ß√£o 1 no gr√°fico)");
      return 1;
   }
   
   if(IsValidInvertedHammer(vela1, current_trend))
   {
      pa_current_pattern = 6; 
      pa_current_description = "Martelo Invertido"; 
      pa_current_color = COL_CONTRA_TREND;
      DrawPriceActionNumber(1, "1", pa_current_color, current_trend);
      pa_bullish = true; 
      Print("‚úÖ Martelo Invertido Bullish confirmado na Vela1 FECHADA (Posi√ß√£o 1 no gr√°fico)");
      return 6;
   }
   
   if(IsValidMarubozu(vela1, true))
   {
      pa_current_pattern = 11; 
      pa_current_description = "Marubozu Bullish"; 
      pa_current_color = COL_TREND_UP;
      DrawPriceActionNumber(1, "1", pa_current_color, current_trend);
      pa_bullish = true; 
      Print("‚úÖ Marubozu Bullish confirmado na Vela1 FECHADA (Posi√ß√£o 1 no gr√°fico)");
      return 11;
   }
   
   // Padr√µes Bearish de 1 vela na Vela1 FECHADA
   if(IsValidShootingStar(vela1, current_trend))
   {
      pa_current_pattern = 3; 
      pa_current_description = "Shooting Star"; 
      pa_current_color = COL_CONTRA_TREND;
      DrawPriceActionNumber(1, "1", pa_current_color, current_trend);
      pa_bearish = true; 
      Print("‚úÖ Shooting Star Bearish confirmado na Vela1 FECHADA (Posi√ß√£o 1 no gr√°fico)");
      return 3;
   }
   
   if(IsValidHangingMan(vela1, current_trend))
   {
      pa_current_pattern = 7; 
      pa_current_description = "Homem Pendurado"; 
      pa_current_color = COL_CONTRA_TREND;
      DrawPriceActionNumber(1, "1", pa_current_color, current_trend);
      pa_bearish = true; 
      Print("‚úÖ Homem Pendurado Bearish confirmado na Vela1 FECHADA (Posi√ß√£o 1 no gr√°fico)");
      return 7;
   }
   
   if(IsValidMarubozu(vela1, false))
   {
      pa_current_pattern = 12; 
      pa_current_description = "Marubozu Bearish"; 
      pa_current_color = COL_TREND_DOWN;
      DrawPriceActionNumber(1, "1", pa_current_color, current_trend);
      pa_bearish = true; 
      Print("‚úÖ Marubozu Bearish confirmado na Vela1 FECHADA (Posi√ß√£o 1 no gr√°fico)");
      return 12;
   }
   
   // ‚úÖ PADR√ïES DE 2 VELAS FECHADAS (Vela2 + Vela1)
   Print("üéØ Analisando padr√µes de 2 velas FECHADAS (Vela2 + Vela1)...");
   
   // üî• BULLISH ENGULFING CORRETO - VELAS FECHADAS
   if(IsValidBullishEngulfing(vela1, vela2))
   {
      pa_current_pattern = 4; 
      pa_current_description = "Bullish Engulfing"; 
      pa_current_color = COL_CONTRA_TREND;
      DrawPriceActionNumber(2, "2", pa_current_color, current_trend);
      DrawPriceActionNumber(1, "1", pa_current_color, current_trend);
      pa_bullish = true; 
      Print("‚úÖ‚úÖ‚úÖ BULLISH ENGULFING CONFIRMADO:");
      Print("   Vela2 (Bearish) na Posi√ß√£o 2 do gr√°fico");
      Print("   Vela1 (Bullish) na Posi√ß√£o 1 do gr√°fico");
      Print("   Sinal: BULLISH (revers√£o de baixa para alta)");
      return 4;
   }
   
   // üî• BEARISH ENGULFING CORRETO - VELAS FECHADAS
   if(IsValidBearishEngulfing(vela1, vela2))
   {
      pa_current_pattern = 5; 
      pa_current_description = "Bearish Engulfing"; 
      pa_current_color = COL_CONTRA_TREND;
      DrawPriceActionNumber(2, "2", pa_current_color, current_trend);
      DrawPriceActionNumber(1, "1", pa_current_color, current_trend);
      pa_bearish = true; 
      Print("‚úÖ‚úÖ‚úÖ BEARISH ENGULFING CONFIRMADO:");
      Print("   Vela2 (Bullish) na Posi√ß√£o 2 do gr√°fico");
      Print("   Vela1 (Bearish) na Posi√ß√£o 1 do gr√°fico");
      Print("   Sinal: BEARISH (revers√£o de alta para baixa)");
      return 5;
   }
   
   // Outros padr√µes de 2 velas FECHADAS
   if(IsValidPiercingLine(vela1, vela2))
   {
      pa_current_pattern = 8; 
      pa_current_description = "Piercing Line"; 
      pa_current_color = COL_CONTRA_TREND;
      DrawPriceActionNumber(2, "2", pa_current_color, current_trend);
      DrawPriceActionNumber(1, "1", pa_current_color, current_trend);
      pa_bullish = true; 
      Print("‚úÖ Piercing Line confirmado (Vela2 + Vela1)");
      return 8;
   }
   
   if(IsValidDarkCloudCover(vela1, vela2))
   {
      pa_current_pattern = 9; 
      pa_current_description = "Dark Cloud Cover"; 
      pa_current_color = COL_CONTRA_TREND;
      DrawPriceActionNumber(2, "2", pa_current_color, current_trend);
      DrawPriceActionNumber(1, "1", pa_current_color, current_trend);
      pa_bearish = true; 
      Print("‚úÖ Dark Cloud Cover confirmado (Vela2 + Vela1)");
      return 9;
   }
   
   // ‚úÖ PADR√ïES DE 3 VELAS FECHADAS (Vela3 + Vela2 + Vela1)
   Print("üéØ Analisando padr√µes de 3 velas FECHADAS (Vela3 + Vela2 + Vela1)...");
   
   if(IsValidThreeWhiteSoldiers(rates, count))
   {
      pa_current_pattern = 13; 
      pa_current_description = "3 Soldados Brancos"; 
      pa_current_color = COL_TREND_UP;
      DrawPriceActionNumber(3, "3", pa_current_color, current_trend);
      DrawPriceActionNumber(2, "2", pa_current_color, current_trend);
      DrawPriceActionNumber(1, "1", pa_current_color, current_trend);
      pa_bullish = true; 
      Print("‚úÖ 3 Soldados Brancos confirmado:");
      Print("   Vela3 na Posi√ß√£o 3 do gr√°fico");
      Print("   Vela2 na Posi√ß√£o 2 do gr√°fico");
      Print("   Vela1 na Posi√ß√£o 1 do gr√°fico");
      return 13;
   }
   
   if(IsValidThreeBlackCrows(rates, count))
   {
      pa_current_pattern = 14; 
      pa_current_description = "3 Corvos Negros"; 
      pa_current_color = COL_TREND_DOWN;
      DrawPriceActionNumber(3, "3", pa_current_color, current_trend);
      DrawPriceActionNumber(2, "2", pa_current_color, current_trend);
      DrawPriceActionNumber(1, "1", pa_current_color, current_trend);
      pa_bearish = true; 
      Print("‚úÖ 3 Corvos Negros confirmado:");
      Print("   Vela3 na Posi√ß√£o 3 do gr√°fico");
      Print("   Vela2 na Posi√ß√£o 2 do gr√°fico");
      Print("   Vela1 na Posi√ß√£o 1 do gr√°fico");
      return 14;
   }

   Print("‚ùå Nenhum padr√£o de Price Action v√°lido detetado nas 3 velas fechadas");
   return 0;
}

bool AnalyzePriceAction(ENUM_TIMEFRAMES tf, int lookback_candles)
{
   if(!ENABLE_PRICE_ACTION)  
   {
      pa_text = "PA: INATIVO";
      pa_valid = false;
      pa_pattern = "NENHUM";
      pa_active = false;
      ClearPriceActionMarkers();
      return false;
   }
   
   MqlRates rates[];
   // ‚úÖ CORRE√á√ÉO CR√çTICA: Buscar APENAS velas FECHADAS (shift 1 para evitar vela atual)
   int copied = CopyRates(_Symbol, tf, 1, 3, rates); // 3 √∫ltimas velas FECHADAS
   
   if(copied < 3)
   {
      pa_text = "PA: DADOS INSUFICIENTES";
      pa_valid = false;
      pa_pattern = "NENHUM";
      pa_active = false;
      ClearPriceActionMarkers();
      Print("‚ùå N√£o h√° 3 velas fechadas dispon√≠veis: " + IntegerToString(copied));
      return false;
   }
   
   // ‚úÖ AGORA TODAS AS 3 VELAS EST√ÉO FECHADAS
   datetime vela1_time = rates[0].time; // Vela MAIS RECENTE FECHADA
   datetime vela2_time = rates[1].time; // 2¬™ vela FECHADA
   datetime vela3_time = rates[2].time; // 3¬™ vela FECHADA
   
   Print("üéØüéØüéØ ANALISANDO 3 VELAS FECHADAS üéØüéØüéØ");
   Print("   Vela1 (MAIS RECENTE): " + TimeToString(vela1_time) + " - FECHADA");
   Print("   Vela2 (2¬™ RECENTE): " + TimeToString(vela2_time) + " - FECHADA");  
   Print("   Vela3 (3¬™ RECENTE): " + TimeToString(vela3_time) + " - FECHADA");
   
   // Limpar marcadores anteriores
   ClearPriceActionMarkers();
   
   int pattern_number = DetectPriceActionPattern(rates, copied, tf);
   
   if(pattern_number > 0)
   {
      pa_last_pattern_time = vela1_time;
      pa_active = true;
      pa_valid = true;
      pa_text = "PA: " + pa_current_description;
      pa_pattern = pa_current_description;
      pa_color = pa_current_color;
      
      Print("‚úÖ‚úÖ‚úÖ PADR√ÉO CONFIRMADO EM VELAS FECHADAS: " + pa_current_description + " ‚úÖ‚úÖ‚úÖ");
      Print("   Vela1: " + TimeToString(vela1_time) + " | Vela2: " + TimeToString(vela2_time) + " | Vela3: " + TimeToString(vela3_time));
      
      return true;
   }
   else
   {
      pa_active = false;
      pa_valid = false;
      pa_text = "PA: NENHUM PATTERN";
      pa_pattern = "NENHUM";
      pa_color = COL_PA_NEUTRAL;
      Print("‚ùå Nenhum padr√£o v√°lido nas 3 velas fechadas");
      return false;
   }
}

//‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
//‚ñà  SEC√á√ÉO 9: MULTI TIMEFRAME CONFIRMATION                         ‚ñà
//‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà

string CheckMTFConfirmation(ENUM_TIMEFRAMES current_tf)
{
   if(!ENABLE_MTF_CONFIRMATION) 
      return "";
   
   double price = SymbolInfoDouble(_Symbol, SYMBOL_BID);
   int trend_current = IdentifyTrend(current_tf, price);
   
   string aligned_tfs = "";
   string direction = "";
   
   string valid_tfs[];
   int valid_count = 0;
   ArrayResize(valid_tfs, 10);
   
   ENUM_TIMEFRAMES timeframes[6] = {PERIOD_M5, PERIOD_M15, PERIOD_M30, PERIOD_H1, PERIOD_H4, PERIOD_D1};
   
   for(int i = 0; i < 6; i++)
   {
      ENUM_TIMEFRAMES tf = timeframes[i];
      if(tf <= current_tf) continue;
      
      int tf_trend = IdentifyTrend(tf, price);
      string tf_name = GetSimpleTFName(tf);
      
      if(tf_trend == trend_current && trend_current != 0)
      {
         valid_tfs[valid_count] = tf_name;
         valid_count++;
         Print("‚úì ", tf_name, " ALINHADO");
      }
      else
      {
         Print("‚úó ", tf_name, " N√ÉO ALINHADO (", tf_trend, " vs ", trend_current, ")");
      }
   }
   
   for(int i = 0; i < valid_count; i++)
   {
      if(aligned_tfs != "") aligned_tfs += ",";
      aligned_tfs += valid_tfs[i];
   }
   
   if(valid_count >= 3)
   {
      direction = (trend_current == 1) ? "‚Üë‚Üë‚Üë" : "‚Üì‚Üì‚Üì";
   }
   else if(valid_count == 2)
   {
      direction = (trend_current == 1) ? "‚Üë‚Üë" : "‚Üì‚Üì";
   }
   else if(valid_count == 1)
   {
      direction = (trend_current == 1) ? "‚Üë" : "‚Üì";
   }
   else if(trend_current == 0)
   {
      direction = "‚Üî";
   }
   else
   {
      direction = "‚úó";
   }
   
   Print("=== AN√ÅLISE MTF ===");
   Print("Current TF (", GetSimpleTFName(current_tf), "): ", trend_current);
   Print("Timeframes Alinhados: ", aligned_tfs, " (", valid_count, " confirma√ß√µes)");
   Print("Dire√ß√£o: ", direction);
   
   mtf_direction = direction;
   return aligned_tfs;
}

bool IsMTFValidForTrend(int current_trend, string aligned_tfs)
{
   if(!ENABLE_MTF_CONFIRMATION || aligned_tfs == "") 
      return false;
   
   if(current_trend != 0 && aligned_tfs != "")
   {
      Print("MTF V√ÅLIDO: Tend√™ncia ", current_trend, " | Timeframes: ", aligned_tfs);
      return true;
   }
   
   return false;
}

//‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
//‚ñà  SEC√á√ÉO 10: CONTRA-TREND LOGIC                                 ‚ñà
//‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà

bool CheckContraTrendSignal(int trend_direction, double rsi, bool support_valid, bool resistance_valid, bool pa_bullish_local, bool pa_bearish_local)
{
   contra_trend_signal = false;
   contra_trend_type = "";
   
   if(trend_direction == -1 && rsi <= 25 && support_valid && pa_bullish_local)
   {
      contra_trend_signal = true;
      contra_trend_type = "COMPRA";
      Print("‚úÖ SINAL CONTRA-TEND√äNCIA: COMPRA (Suporte + RSI Oversold + PA Bullish)");
      return true;
   }
   
   if(trend_direction == 1 && rsi >= 75 && resistance_valid && pa_bearish_local)
   {
      contra_trend_signal = true;
      contra_trend_type = "VENDA";
      Print("‚úÖ SINAL CONTRA-TEND√äNCIA: VENDA (Resist√™ncia + RSI Overbought + PA Bearish)");
      return true;
   }
   
   return false;
}

//‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
//‚ñà  SEC√á√ÉO 11: FUN√á√ÉO AUXILIAR: COR DO RSI                         ‚ñà
//‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà

color GetRSIColor(double rsi_value)
{
   if(rsi_value <= 30) return COL_RSI_OVERSOLD;
   if(rsi_value >= 70) return COL_RSI_OVERBOUGHT;
   return COL_RSI_NEUTRAL;
}

//‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
//‚ñà  SEC√á√ÉO 12: SISTEMA DE ALERTAS (MODIFICADO - SOM DE 2 SEGUNDOS) ‚ñà
//‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà

void PlayShortSound()
{
    if(SOUND_ALERTS && !sound_playing)
    {
        PlaySound(ALERT_SOUND);
        sound_playing = true;
        last_sound_time = TimeCurrent();
        
        Print("üîä ALERTA SONORO ATIVADO - 2 SEGUNDOS");
    }
}

void StopSound()
{
    if(sound_playing)
    {
        PlaySound(NULL); // Para o som
        sound_playing = false;
        Print("üîá ALERTA SONORO FINALIZADO");
    }
}

void CheckAndAlert(string signal_type, string signal_description, int confluences_count)
{
    if(!ENABLE_ALERTS) 
        return;
    
    string current_candle = IntegerToString(iTime(_Symbol, _Period, 0));
    
    // Verifica se √© um novo sinal v√°lido (3 conflu√™ncias SEM MTF)
    bool valid_signal = (confluences_count >= 3);
    
    // Verifica se √© uma nova vela e tem sinal v√°lido
    if(valid_signal && current_candle != last_signal_candle)
    {
        string alert_message = "MACRO CONFLUENCE - " + signal_type + " - " + _Symbol + 
                              " (" + GetSimpleTFName((ENUM_TIMEFRAMES)Period()) + ") - " + signal_description;
        
        Print("üîî NOVO SINAL: " + alert_message);
        Print("üéØ Conflu√™ncias ativas: " + IntegerToString(confluences_count) + " (MTF n√£o conta)");
        
        // Ativa alerta visual
        Alert(alert_message);
        
        // Ativa alerta sonoro (apenas 1 vez por vela)
        PlayShortSound();
        
        // Marca que j√° alertou nesta vela
        last_signal_candle = current_candle;
    }
    else if(valid_signal && current_candle == last_signal_candle)
    {
        Print("‚è≠Ô∏è  Alerta j√° emitido nesta vela - Aguardando pr√≥xima vela");
    }
}

void ProcessFinalSignal(string final_signal, int confluences_count, string trend_direction)
{
    string signal_type = "";
    string signal_description = "";
    
    // Remove MTF da contagem para o alerta sonoro
    int confluences_for_sound = confluences_count;
    
    if(StringFind(final_signal, "COMPRA") >= 0)
    {
        if(StringFind(final_signal, "CONTRA-TEND√äNCIA") >= 0)
        {
            signal_type = "COMPRA_CONTRA_TENDENCIA";
            signal_description = "Contra-tend√™ncia com " + IntegerToString(confluences_for_sound) + " conflu√™ncias";
        }
        else
        {
            signal_type = "COMPRA_NORMAL";
            signal_description = "Tend√™ncia " + trend_direction + " con " + IntegerToString(confluences_for_sound) + " conflu√™ncias";
        }
        
        CheckAndAlert(signal_type, signal_description, confluences_for_sound);
    }
    else if(StringFind(final_signal, "VENDA") >= 0)
    {
        if(StringFind(final_signal, "CONTRA-TEND√äNCIA") >= 0)
        {
            signal_type = "VENDA_CONTRA_TENDENCIA";
            signal_description = "Contra-tend√™ncia com " + IntegerToString(confluences_for_sound) + " conflu√™ncias";
        }
        else
        {
            signal_type = "VENDA_NORMAL";
            signal_description = "Tend√™ncia " + trend_direction + " con " + IntegerToString(confluences_for_sound) + " conflu√™ncias";
        }
        
        CheckAndAlert(signal_type, signal_description, confluences_for_sound);
    }
    else
    {
        Print("‚è≥ " + final_signal + " - Aguardando 3 conflu√™ncias ativas");
    }
}

//‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
//‚ñà  SEC√á√ÉO 13: PAINEL VISUAL (CORRIGIDA - MAIOR ESPA√áAMENTO)     ‚ñà
//‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà

void CreateVisualPanel(string trend, color t_color, string final_signal, color s_color, double price,
                      int active_confluences_normal, int active_confluences_contra, double rsi_value,
                      bool has_mtf_normal, bool has_mtf_contra)
{
   int x_pos = 300;
   int y_pos = 350;
   
   if(trend == "BAIXA")
   {
      y_pos = 60;
   }
   
   Print("=== POSI√á√ÉO DO PAINEL ===");
   Print("Tend√™ncia: ", trend, " | Posi√ß√£o X: ", x_pos, " | Posi√ß√£o Y: ", y_pos);
   
   color text_color = DARK_MODE ? clrWhite : clrBlack;
   
   // Limpar objetos antigos do painel
   for(int i = ObjectsTotal(0) - 1; i >= 0; i--)
   {
      string name = ObjectName(0, i);
      if(StringFind(name, PREFIX) == 0 && 
         StringFind(name, "FIB_") == -1 && 
         StringFind(name, "PA_") == -1)
      {
         ObjectDelete(0, name);
      }
   }
   
   int line_y = y_pos;
   int line_height = 22; // AUMENTADO de 18 para 22 pixels
   
   CreatePanelLabel("Symbol", x_pos, line_y, text_color, _Symbol + " | " + GetSimpleTFName((ENUM_TIMEFRAMES)Period()));
   CreatePanelLabel("Price", x_pos, line_y + 20, text_color, "Pre√ßo: " + FormatPrice(price));
   CreatePanelLabel("Trend", x_pos, line_y + 40, t_color, "TEND√äNCIA: " + trend);
   
   line_y += 70; // AUMENTADO de 60 para 70
   
   // ‚úÖ MTF SEPARADO - ABAIXO DA TEND√äNCIA EM AZUL
   if(mtf_valid_normal && mtf_aligned_tfs != "") 
   {
      CreatePanelLabel("MTF_Separado", x_pos, line_y, clrBlue, "MTF ALINHADO: " + mtf_direction + " " + mtf_aligned_tfs);
      line_y += 25; // AUMENTADO de 20 para 25
   }
   
   // ‚úÖ ESPA√áAMENTO MAIOR ENTRE MTF E CONFLU√äNCIAS
   line_y += 20; // AUMENTADO de 15 para 20 pixels
   
   // CONFLU√äNCIAS REAIS (SEM MTF)
   string normal_header = "CONFLU√äNCIAS ATIVAS: " + IntegerToString(active_confluences_normal);
   if(has_mtf_normal)
   {
      normal_header = "CONFLU√äNCIAS ATIVAS: " + IntegerToString(active_confluences_normal - 1);
   }
   CreatePanelLabel("NormHeader", x_pos, line_y, text_color, normal_header);
   line_y += 25; // AUMENTADO de 20 para 25
   
   color normal_color = (trend == "ALTA") ? clrDarkGreen : clrDarkRed;
   
   if(support_valid_normal) 
   {
      string support_text = "‚úì SUPORTE PR√ìXIMO (" + FormatPrice(current_support_level) + ")";
      CreatePanelLabel("Support_Normal", x_pos, line_y, normal_color, support_text);
      line_y += line_height;
   }
   
   if(resistance_valid_normal) 
   {
      string resistance_text = "‚úì RESIST√äNCIA PR√ìXIMA (" + FormatPrice(current_resistance_level) + ")";
      CreatePanelLabel("Resistance_Normal", x_pos, line_y, normal_color, resistance_text);
      line_y += line_height;
   }
   
   if(rsi_oversold_normal) 
   {
      CreatePanelLabel("RSI_Oversold_Normal", x_pos, line_y, normal_color, "‚úì RSI OVERSOLD (" + DoubleToString(rsi_value, 1) + ")");
      line_y += line_height;
   }
   
   if(rsi_overbought_normal) 
   {
      CreatePanelLabel("RSI_Overbought_Normal", x_pos, line_y, normal_color, "‚úì RSI OVERBOUGHT (" + DoubleToString(rsi_value, 1) + ")");
      line_y += line_height;
   }
   
   if(fib_valid_normal) 
   {
      CreatePanelLabel("FIB_Normal", x_pos, line_y, normal_color, "‚úì FIBONACCI GOLDEN ZONE");
      line_y += line_height;
   }
   
   if(pa_valid_normal && pa_pattern != "NENHUM") 
   {
      CreatePanelLabel("PA_Normal", x_pos, line_y, normal_color, "‚úì " + pa_pattern);
      line_y += line_height;
   }
   
   // ‚úÖ ESPA√áAMENTO MUITO MAIOR ENTRE CONFLU√äNCIAS NORMAIS E CONTRA-TEND√äNCIA
   line_y += 35; // AUMENTADO de 25 para 35 pixels - ESPA√áAMENTO EXTRA
   
   CreatePanelLabel("ContraHeader", x_pos, line_y, text_color, "CONFLU√äNCIAS CONTRA-TEND√äNCIA: " + IntegerToString(active_confluences_contra));
   line_y += 25; // AUMENTADO de 20 para 25
   
   color contra_color = (trend == "ALTA") ? clrDarkRed : clrDarkGreen;
   
   if(support_valid_contra) 
   {
      string support_text = "‚úì SUPORTE PR√ìXIMO (" + FormatPrice(current_support_level) + ")";
      CreatePanelLabel("Support_CT", x_pos, line_y, contra_color, support_text);
      line_y += line_height;
   }
   
   if(resistance_valid_contra) 
   {
      string resistance_text = "‚úì RESIST√äNCIA PR√ìXIMA (" + FormatPrice(current_resistance_level) + ")";
      CreatePanelLabel("Resistance_CT", x_pos, line_y, contra_color, resistance_text);
      line_y += line_height;
   }
   
   if(rsi_oversold_contra) 
   {
      CreatePanelLabel("RSI_Oversold_CT", x_pos, line_y, contra_color, "‚úì RSI EXTREMO OVERSOLD (" + DoubleToString(rsi_value, 1) + ")");
      line_y += line_height;
   }
   
   if(rsi_overbought_contra) 
   {
      CreatePanelLabel("RSI_Overbought_CT", x_pos, line_y, contra_color, "‚úì RSI EXTREMO OVERBOUGHT (" + DoubleToString(rsi_value, 1) + ")");
      line_y += line_height;
   }
   
   if(fib_valid_contra) 
   {
      CreatePanelLabel("FIB_CT", x_pos, line_y, contra_color, "‚úì FIBONACCI GOLDEN ZONE");
      line_y += line_height;
   }
   
   if(pa_valid_contra && pa_pattern != "NENHUM") 
   {
      CreatePanelLabel("PA_CT", x_pos, line_y, contra_color, "‚úì " + pa_pattern);
      line_y += line_height;
   }
   
   line_y += 25; // AUMENTADO de 20 para 25
   
   CreatePanelLabel("SignalHeader", x_pos, line_y, text_color, "SINAL FINAL:", FONT_SIZE + 1);
   
   string final_signal_text = final_signal;
   color final_signal_color = clrBlack;
   int final_signal_size = FONT_SIZE + 4;
   
   if(StringFind(final_signal, "COMPRA") >= 0 && StringFind(final_signal, "ALERTA") == -1)
   {
      final_signal_color = clrDarkGreen;
      final_signal_size = FONT_SIZE + 5;
   }
   else if(StringFind(final_signal, "VENDA") >= 0 && StringFind(final_signal, "ALERTA") == -1)
   {
      final_signal_color = clrDarkRed;
      final_signal_size = FONT_SIZE + 5;
   }
   
   CreatePanelLabel("FinalSignal", x_pos, line_y + 30, final_signal_color, final_signal_text, final_signal_size); // AUMENTADO de 25 para 30
}

//‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
//‚ñà  SEC√á√ÉO 14: CONTAGEM DE CONFLU√äNCIAS (MODIFICADA)              ‚ñà
//‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà

void CountConfluencesWithMTF(bool is_contra_trend, int &count, int &count_without_mtf, bool &has_mtf)
{
   count = 0;
   count_without_mtf = 0;
   has_mtf = false;
   
   if(is_contra_trend)
   {
      if(rsi_oversold_contra) { count++; count_without_mtf++; }
      if(rsi_overbought_contra) { count++; count_without_mtf++; }
      if(support_valid_contra) { count++; count_without_mtf++; }
      if(resistance_valid_contra) { count++; count_without_mtf++; }
      if(fib_valid_contra) { count++; count_without_mtf++; }
      if(pa_valid_contra) { count++; count_without_mtf++; }
      // MTF n√£o conta para contra-tend√™ncia
   }
   else
   {
      if(rsi_oversold_normal) { count++; count_without_mtf++; }
      if(rsi_overbought_normal) { count++; count_without_mtf++; }
      if(support_valid_normal) { count++; count_without_mtf++; }
      if(resistance_valid_normal) { count++; count_without_mtf++; }
      if(fib_valid_normal) { count++; count_without_mtf++; }
      if(pa_valid_normal) { count++; count_without_mtf++; }
      if(mtf_valid_normal) 
      {
         count++; // MTF conta para display geral APENAS
         has_mtf = true;
         // count_without_mtf N√ÉO incrementa - MTF n√£o conta como conflu√™ncia ativa
      }
   }
   
   Print("üî¢ Contagem Conflu√™ncias: Total=" + IntegerToString(count) + 
         " | Conflu√™ncias_Reais=" + IntegerToString(count_without_mtf) + 
         " | MTF_Ativo=" + (has_mtf ? "SIM" : "N√ÉO"));
}

//‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
//‚ñà  SEC√á√ÉO 15: FUN√á√ÉO PRINCIPAL UPDATEALL (CORRE√á√ïES CR√çTICAS)   ‚ñà
//‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà

void UpdateAll()
{
   if(TimeCurrent() - last_calculation < calculation_interval) 
      return;
   last_calculation = TimeCurrent();
   
   // ‚úÖ CORRE√á√ÉO: Para o som se j√° passaram 2 segundos
   if(sound_playing && (TimeCurrent() - last_sound_time >= 2))
   {
      StopSound();
   }
   
   ENUM_TIMEFRAMES chart_tf = (ENUM_TIMEFRAMES)Period();
   
   if(!BuildHandlesForTF(chart_tf)) 
   {
      Print("‚ùå ERRO: Falha ao criar handles dos indicadores");
      return;
   }
   
   double rsi, sma200;
   if(!ReadOne(handle_rsi_chart, rsi) || !ReadOne(handle_sma_chart, sma200)) 
   {
      Print("‚ùå ERRO: Falha ao ler indicadores RSI/SMA");
      return;
   }
   
   double price = SymbolInfoDouble(_Symbol, SYMBOL_BID);
   int trend_direction = IdentifyTrend(chart_tf, price);
   string trend_text = trend_direction == 1 ? "ALTA" : (trend_direction == -1 ? "BAIXA" : "LATERAL");
   color trend_color = trend_direction == 1 ? COL_TREND_UP : (trend_direction == -1 ? COL_TREND_DOWN : COL_TREND_SIDE);
   
   Print("=== AN√ÅLISE INICIADA ===");
   Print("Tend√™ncia: ", trend_text, " | Pre√ßo: ", FormatPrice(price), " | RSI: ", DoubleToString(rsi, 1));
   
   // ‚úÖ CORRE√á√ÉO: Reset COMPLETO das vari√°veis de conflu√™ncia
   support_valid_normal = false; resistance_valid_normal = false;
   support_valid_contra = false; resistance_valid_contra = false;
   rsi_oversold_normal = false; rsi_overbought_normal = false;
   rsi_oversold_contra = false; rsi_overbought_contra = false;
   fib_valid_normal = false; fib_valid_contra = false;
   pa_valid_normal = false; pa_valid_contra = false;
   mtf_valid_normal = false; mtf_valid_contra = false;
   
   // 1. SISTEMA SIMPLIFICADO DE SUPORTE E RESIST√äNCIA
   double support_level = 0, resistance_level = 0;
   int support_touches = 0, resistance_touches = 0;
   
   if(SHOW_SUPPORT_RESISTANCE)
   {
      bool sr_calculated = CalculateSmartSupportResistance(chart_tf, support_level, resistance_level, support_touches, resistance_touches);
      
      if(sr_calculated)
      {
         current_support_level = support_level;
         current_resistance_level = resistance_level;
         
         // ‚úÖ CORRE√á√ÉO: VERIFICA√á√ÉO SIMPLIFICADA MAS EFICAZ
         support_valid_normal = (trend_direction == 1 && IsNearStrongSR(price, support_level, support_touches, "SUPORTE"));
         resistance_valid_normal = (trend_direction == -1 && IsNearStrongSR(price, resistance_level, resistance_touches, "RESIST√äNCIA"));
         
         support_valid_contra = (trend_direction == -1 && IsNearStrongSR(price, support_level, support_touches, "SUPORTE"));
         resistance_valid_contra = (trend_direction == 1 && IsNearStrongSR(price, resistance_level, resistance_touches, "RESIST√äNCIA"));
         
         Print("=== S/R SIMPLES ===");
         Print("Suporte: " + FormatPrice(support_level));
         Print("Resist√™ncia: " + FormatPrice(resistance_level));
         Print("Suporte Normal Ativo: ", support_valid_normal);
         Print("Resist√™ncia Normal Ativa: ", resistance_valid_normal);
         Print("Suporte Contra Ativo: ", support_valid_contra);
         Print("Resist√™ncia Contra Ativa: ", resistance_valid_contra);
      }
      else
      {
         Print("‚ùå Falha no c√°lculo de S/R simples");
      }
   }
   
   // 2. RSI - ‚úÖ CORRE√á√ÉO: L√ìGICA SIMPLIFICADA
   if(SHOW_RSI)
   {
      rsi_oversold_normal = (trend_direction == 1 && rsi <= 30);
      rsi_overbought_normal = (trend_direction == -1 && rsi >= 70);
      rsi_oversold_contra = (trend_direction == -1 && rsi <= 25);
      rsi_overbought_contra = (trend_direction == 1 && rsi >= 75);
      
      Print("=== RSI ===");
      Print("RSI: ", DoubleToString(rsi, 1));
      Print("Oversold Normal: ", rsi_oversold_normal);
      Print("Overbought Normal: ", rsi_overbought_normal);
      Print("Oversold Contra: ", rsi_oversold_contra);
      Print("Overbought Contra: ", rsi_overbought_contra);
   }
   
   // 3. PRICE ACTION - ‚úÖ CORRE√á√ÉO: APENAS VELAS FECHADAS
   bool pa_analysis_result = false;
   if(SHOW_PRICE_ACTION)
   {
      pa_analysis_result = AnalyzePriceAction(chart_tf, PA_CANDLES_LOOKBACK);
      pa_valid_normal = (trend_direction == 1 && pa_bullish) || (trend_direction == -1 && pa_bearish);
      pa_valid_contra = (trend_direction == -1 && pa_bullish) || (trend_direction == 1 && pa_bearish);
      
      Print("=== PRICE ACTION ===");
      Print("Pattern: ", pa_pattern);
      Print("Bullish: ", pa_bullish, " | Bearish: ", pa_bearish);
      Print("PA Normal Ativo: ", pa_valid_normal);
      Print("PA Contra Ativo: ", pa_valid_contra);
      Print("PA An√°lise Resultado: ", pa_analysis_result);
   }
   else
   {
      // Se PRICE ACTION est√° desativado, limpa todos os marcadores
      ClearPriceActionMarkers();
      pa_text = "PA: INATIVO";
      pa_pattern = "NENHUM";
      pa_valid_normal = false;
      pa_valid_contra = false;
   }
   
   // 4. MULTI TIMEFRAME - ‚úÖ CORRE√á√ÉO: VARI√ÅVEIS GLOBAIS
   mtf_aligned_tfs = CheckMTFConfirmation(chart_tf);
   mtf_valid_normal = IsMTFValidForTrend(trend_direction, mtf_aligned_tfs);
   mtf_valid_contra = false; // Contra-tend√™ncia n√£o usa MTF
   
   Print("=== MULTI TIMEFRAME ===");
   Print("MTF Alinhados: ", mtf_aligned_tfs);
   Print("MTF V√°lido Normal: ", mtf_valid_normal);
   Print("MTF V√°lido Contra: ", mtf_valid_contra);
   
   // 5. FIBONACCI - ‚úÖ CORRE√á√ÉO: L√ìGICA COMPLETAMENTE REVISADA
   double fib_0 = 0, fib_50 = 0, fib_618 = 0, fib_100 = 0, fib_786 = 0, fib_382 = 0;
   fib_valid_normal = false;
   fib_valid_contra = false; // Fibonacci n√£o √© usado em contra-tend√™ncia

   if(SHOW_FIBONACCI && trend_direction != 0)
   {
      bool fib_calculated = ComputeFibLevels(chart_tf, trend_direction, fib_0, fib_50, fib_618, fib_100, fib_786, fib_382);
      
      if(fib_calculated)
      {
         Print("üéØüéØüéØ FIBONACCI CALCULADO ===");
         Print("0%: ", FormatPrice(fib_0), " | 50%: ", FormatPrice(fib_50), " | 61.8%: ", FormatPrice(fib_618), " | 100%: ", FormatPrice(fib_100));
         
         bool should_remove = ShouldRemoveFibonacci(price, fib_0, fib_100, trend_direction);
         
         if(!should_remove)
         {
            DrawFibonacciLevels(fib_0, fib_50, fib_618, fib_100, trend_direction);
            
            // ‚úÖ‚úÖ‚úÖ VERIFICA√á√ÉO ESTRITA: CONFLU√äNCIA ATIVA APENAS ENTRE 50%-61.8%
            fib_valid_normal = IsFibonacciActive(price, fib_50, fib_618, trend_direction);
            
            if(fib_valid_normal)
            {
               Print("‚úÖ‚úÖ‚úÖ FIBONACCI GOLDEN ZONE - Conflu√™ncia ATIVA (50%-61.8%)");
            }
            else
            {
               Print("‚ùå‚ùå‚ùå Fibonacci INATIVO - Fora da Golden Zone 50%-61.8%");
            }
         }
         else
         {
            ClearFibonacciLevels();
            fib_valid_normal = false;
            Print("üî¥üî¥üî¥ Fibonacci REMOVIDO - Pre√ßo fora dos limites 45%-65%");
         }
      }
      else
      {
         ClearFibonacciLevels();
         fib_valid_normal = false;
         Print("Fibonacci: N√£o calculado - movimento insuficiente");
      }
   }
   else if(SHOW_FIBONACCI && trend_direction == 0)
   {
      ClearFibonacciLevels();
      fib_valid_normal = false;
      Print("Fibonacci: Bloqueado - tend√™ncia lateral");
   }
   else if(!SHOW_FIBONACCI)
   {
      // ‚úÖ SE FIBONACCI EST√Å DESATIVADO, LIMPAR TUDO
      ClearFibonacciLevels();
      fib_valid_normal = false;
   }
   
   // 6. VERIFICA√á√ÉO DE CONTRA-TEND√äNCIA - ‚úÖ CORRE√á√ÉO: L√ìGICA SIMPLIFICADA
   bool contra_signal = CheckContraTrendSignal(trend_direction, rsi, support_valid_contra, resistance_valid_contra, pa_bullish, pa_bearish);
   
   Print("=== CONTRA-TEND√äNCIA ===");
   Print("Sinal Contra: ", contra_signal);
   Print("Tipo Contra: ", contra_trend_type);
   
   // 7. CONTAGEM DE CONFLU√äNCIAS - ‚úÖ CORRE√á√ÉO: CONTAGEM PRECISA
   int confluences_normal = 0, confluences_contra = 0;
   int confluences_normal_no_mtf = 0, confluences_contra_no_mtf = 0;
   bool has_mtf_normal = false, has_mtf_contra = false;
   
   CountConfluencesWithMTF(false, confluences_normal, confluences_normal_no_mtf, has_mtf_normal);
   CountConfluencesWithMTF(true, confluences_contra, confluences_contra_no_mtf, has_mtf_contra);
   
   Print("=== CONTAGEM DE CONFLU√äNCIAS ===");
   Print("Conflu√™ncias Normal: ", confluences_normal, " (Reais: ", confluences_normal_no_mtf, ")");
   Print("Conflu√™ncias Contra: ", confluences_contra, " (Reais: ", confluences_contra_no_mtf, ")");
   Print("MTF Normal: ", has_mtf_normal, " | MTF Contra: ", has_mtf_contra);
   
   // ‚úÖ CORRE√á√ÉO: Limpeza de PA se n√£o est√° ativo
   if(SHOW_PRICE_ACTION && !pa_valid_normal && !pa_valid_contra && pa_active)
   {
      Print("üîÅ PA deixou de estar ativo - limpando marcadores");
      ClearPriceActionMarkers();
      pa_active = false;
   }
   
   // 8. DETERMINA√á√ÉO DO SINAL FINAL - ‚úÖ CORRE√á√ÉO: L√ìGICA PRIORIT√ÅRIA
   string final_signal = "AGUARDAR";
   color signal_color = COL_ACTION_WAIT;
   int active_confluences = 0;
   int active_confluences_for_sound = 0;

   bool strong_signal_normal = (confluences_normal_no_mtf >= 3);
   bool strong_signal_contra = (confluences_contra_no_mtf >= 3);
   bool moderate_signal_normal = (confluences_normal_no_mtf >= 2 && has_mtf_normal);

   if(contra_signal && strong_signal_contra)
   {
      final_signal = (contra_trend_type == "COMPRA") ? "COMPRA (CONTRA-TEND√äNCIA)" : "VENDA (CONTRA-TEND√äNCIA)";
      signal_color = COL_CONTRA_TREND;
      active_confluences = confluences_contra;
      active_confluences_for_sound = confluences_contra_no_mtf;
      Print("üéØ SINAL CONTRA-TEND√äNCIA ATIVADO - 3+ Conflu√™ncias Reais");
   }
   else if(strong_signal_normal)
   {
      final_signal = trend_direction == 1 ? "COMPRA" : "VENDA";
      signal_color = trend_direction == 1 ? COL_ACTION_BUY : COL_ACTION_SELL;
      active_confluences = confluences_normal;
      active_confluences_for_sound = confluences_normal_no_mtf;
      Print("üéØ SINAL TEND√äNCIA NORMAL FORTE - 3+ Conflu√™ncias Reais");
   }
   else if(moderate_signal_normal)
   {
      final_signal = "ALERTA " + (trend_direction == 1 ? "COMPRA" : "VENDA");
      signal_color = COL_ACTION_WAIT;
      active_confluences = confluences_normal;
      active_confluences_for_sound = confluences_normal_no_mtf;
      Print("‚ö†Ô∏è  SINAL TEND√äNCIA NORMAL MODERADO - 2 Conflu√™ncias Reais + MTF");
   }
   else if(contra_signal && confluences_contra_no_mtf > 0)
   {
      final_signal = "ALERTA " + contra_trend_type + " (CONTRA-FRACO)";
      signal_color = COL_ACTION_WAIT;
      active_confluences = confluences_contra;
      active_confluences_for_sound = confluences_contra_no_mtf;
      Print("‚ö†Ô∏è  SINAL CONTRA-TEND√äNCIA FRACO");
   }
   else
   {
      final_signal = "AGUARDAR CONFLU√äNCIAS";
      signal_color = COL_ACTION_WAIT;
      active_confluences = 0;
      active_confluences_for_sound = 0;
      Print("‚è≥ Aguardando 3 conflu√™ncias reais");
   }

   // 9. SISTEMA DE ALERTAS - ‚úÖ CORRE√á√ÉO: CHAMADA CORRETA
   ProcessFinalSignal(final_signal, active_confluences_for_sound, trend_text);

   // 10. ATUALIZAR PAINEL VISUAL - ‚úÖ CORRE√á√ÉO: PASSAGEM CORRETA DE PAR√ÇMETROS
   CreateVisualPanel(trend_text, trend_color, final_signal, signal_color, price, 
                    confluences_normal, confluences_contra, rsi, has_mtf_normal, has_mtf_contra);
   
   Print("=== AN√ÅLISE CONCLU√çDA ===");
   Print("SINAL FINAL: ", final_signal);
   Print("Conflu√™ncias: ", active_confluences, " | Conflu√™ncias Reais: ", active_confluences_for_sound);
   Print("=================================");
}

//‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
//‚ñà  SEC√á√ÉO 16: FUN√á√ïES DE EVENTOS                                ‚ñà
//‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà

int OnInit()
{
   Print("=== MACROCONFLUENCE PRO v4.25 INICIADO ===");
   Print("Symbol: ", _Symbol, " | Timeframe: ", GetSimpleTFName((ENUM_TIMEFRAMES)Period()));
   Print("Configura√ß√£o: 15 PIPS para S/R | Fibonacci 50%-61.8% com 5% margem");
   Print("Alerta Sonoro: 2 segundos | MTF n√£o conta como conflu√™ncia ativa");
   Print("Sinais: 3 conflu√™ncias reais necess√°rias (MTF √© confirma√ß√£o adicional)");
   
   handle_sma_chart = INVALID_HANDLE;
   handle_rsi_chart = INVALID_HANDLE;
   handle_ema_20 = INVALID_HANDLE;
   handle_ema_50 = INVALID_HANDLE;
   handle_atr = INVALID_HANDLE;
   
   if(!BuildHandlesForTF((ENUM_TIMEFRAMES)Period()))
   {
      Print("ERRO: Falha ao criar handles dos indicadores");
      return(INIT_FAILED);
   }
   
   fib_drawn = false;
   EventSetTimer(1);
   UpdateAll();
   
   return(INIT_SUCCEEDED);
}

void OnDeinit(const int reason)
{
   StopSound(); // Para qualquer som que esteja tocando
   DeleteAllObjects();
   EventKillTimer();
   
   if(handle_sma_chart != INVALID_HANDLE) IndicatorRelease(handle_sma_chart);
   if(handle_rsi_chart != INVALID_HANDLE) IndicatorRelease(handle_rsi_chart);
   if(handle_ema_20 != INVALID_HANDLE) IndicatorRelease(handle_ema_20);
   if(handle_ema_50 != INVALID_HANDLE) IndicatorRelease(handle_ema_50);
   if(handle_atr != INVALID_HANDLE) IndicatorRelease(handle_atr);
   
   Print("=== MACROCONFLUENCE PRO REMOVIDO ===");
}

void OnTimer()
{
   UpdateAll();
}

int OnCalculate(const int rates_total,
                const int prev_calculated,
                const datetime &time[],
                const double &open[],
                const double &high[],
                const double &low[],
                const double &close[],
                const long &tick_volume[],
                const long &volume[],
                const int &spread[])
{
   return(rates_total);
}